<html> 
  <head> 
    <title>Idealize</title> 
    <style>canvas { width: 100%; height: 100% }</style> 
  </head> 
  <body> 
  <script src="js/three.min.js"></script> 
  <!-- <script src="js/d3.v3.min.js"></script>  -->
  <script src="js/underscore.js"></script> 

  <script> 
    var camera, scene, renderer;
    var geometry, material, mesh, ideal;
    var group;

    var targetYRotation = targetXRotation = 0;
    var targetYRotationOnMouseDown = targetXRotationOnMouseDown = 0;

    var mouseX = 0, mouseY = 0;
    var mouseXOnMouseDown = 0;
    var zoomFactor = 1;

    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    var data = [[0,4],[1,4],[1,3],[3,3],[3,2],[4,2],[4,0]];

    function newCube(point, geometry, material) {
      var mesh = new THREE.Mesh( geometry, material );
      mesh.position.x = point[0] - 1/2;
      mesh.position.y = point[1] - 1/2;
      mesh.updateMatrix();
      return mesh;
    }

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0,0,10);
      camera.lookAt(new THREE.Vector3(0,1,0));

      // renderer = new THREE.WebGLRenderer();
      renderer = new THREE.CanvasRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);

      document.body.appendChild(renderer.domElement);

      line_material = new THREE.LineBasicMaterial({color: 0x0000ff});
      material = new THREE.MeshBasicMaterial({color: 0x00ff00, wireframeLinewidth: 1, wireframe:true });
      group = new THREE.Object3D();
      geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(0,0,0));
      var s = 1
      var cube = new THREE.CubeGeometry( s, s, s );
      data.forEach(function (d,i) {
        // var mesh = newCube(d,cube, material);
        // group.add(mesh);
        var vec = new THREE.Vector3(d[0],d[1],0);
        /* points.push(vec);  */
        geometry.vertices.push(vec);
      });
      geometry.vertices.push(new THREE.Vector3(0,0,0));

      // Is this a good way to add squares
      // Probably not...
      var maxX = _.max(data, function(d) { return d[0]; })[0];
      var previousMin = 0;
      for(var i = 1; i < maxX + 1; i++) {
        var colPoints = _.filter(data, function(d) { return d[0] == (i); });
        var maxColY = _.max(colPoints, function(d) { return d[1]; })[1];
        console.log(maxColY);
        if(!maxColY) {
          // console.log(previousMax);
          maxColY = previousMin;
        } 
        else {
          // console.log(maxColY);
          previousMin = _.min(colPoints, function(d) { return d[1]; })[1];
        }
        for(var j = maxColY ; j > 0; j--) {
          var mesh = newCube([i,j],cube, material);
          group.add(mesh);
        }
      }

      /* var shape  = new THREE.Shape(points); */

      ideal = new THREE.Line(geometry, line_material);
      group.add(ideal);
      /* geometry = new THREE.CubeGeometry(1,1,1); */
      /* cube = new THREE.Mesh(geometry, material); */

      scene.add(group);
      /* camera.position.z = 5; */

      document.addEventListener( 'mousedown', onDocumentMouseDown, false );
      document.addEventListener( 'touchstart', onDocumentTouchStart, false );
      document.addEventListener( 'touchmove', onDocumentTouchMove, false );
      document.addEventListener( 'mousewheel', onMouseWheel, false );

      //

      window.addEventListener( 'resize', onWindowResize, false );
    }

    function animate() {
      requestAnimationFrame(animate);

      render();
    }

    function render() {

      group.rotation.x = group.rotation.x += ( targetXRotation - group.rotation.x ) * 0.05;
      group.rotation.y = group.rotation.y += ( targetYRotation - group.rotation.y ) * 0.05;

      renderer.render( scene, camera );

    }
    
    init();
    animate();
function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function onDocumentMouseDown( event ) {

				//event.preventDefault();

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mouseout', onDocumentMouseOut, false );

				mouseXOnMouseDown = event.clientX - windowHalfX;
				mouseYOnMouseDown = event.clientY - windowHalfY;
				targetYRotationOnMouseDown = targetYRotation;
				targetXRotationOnMouseDown = targetXRotation;

			}

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

				targetYRotation = targetYRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;
				targetXRotation = targetXRotationOnMouseDown + ( mouseY - mouseYOnMouseDown ) * 0.02;

			}

			function onDocumentMouseUp( event ) {

				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			function onDocumentMouseOut( event ) {

				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
					targetRotationOnMouseDown = targetRotation;

				}
			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;

				}
      }

      function onMouseWheel( event ) {
        event = event ? event : window.event;
        var wheelData = event.detail ? event.detail : event.wheelDelta;
        console.log(event);

				/* if ( event.touches.length == 1 ) { */

				/* 	event.preventDefault(); */

				/* 	mouseX = event.touches[ 0 ].pageX - windowHalfX; */
				/* 	targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05; */

				/* } */
			}

  </script> 
</body> 
</html>
