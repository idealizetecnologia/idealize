<html> 
  <head> 
    <title>Idealize</title> 
    <style>canvas { width: 100%; height: 100% }</style> 
  </head> 
  <body> 
  <script src="js/three.min.js"></script> 
  <!-- <script src="js/d3.v3.min.js"></script>  -->
  <script src="js/underscore.js"></script> 
		<script type="x-shader/x-vertex" id="vertexShader">

			attribute vec4 center;
			varying vec4 vCenter;

			void main() {

				vCenter = center;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentShader">

			#extension GL_OES_standard_derivatives : enable

			varying vec4 vCenter;

			float edgeFactorTri() {

				vec3 d = fwidth( vCenter.xyz );
				vec3 a3 = smoothstep( vec3( 0.0 ), d * 1.5, vCenter.xyz );
				return min( min( a3.x, a3.y ), a3.z );

			}

			float edgeFactorQuad1() {

				vec2 d = fwidth( vCenter.xy );
				vec2 a2 = smoothstep( vec2( 0.0 ), d * 1.5, vCenter.xy );

				return min( a2.x, a2.y );

			}

			float edgeFactorQuad2() {

				vec2 d = fwidth( 1.0 - vCenter.xy );
				vec2 a2 = smoothstep( vec2( 0.0 ), d * 1.5, 1.0 - vCenter.xy );

				return min( a2.x, a2.y );
			}

			void main() {

				if ( vCenter.w == 0.0 ) {

					gl_FragColor.rgb = mix( vec3( 1.0 ), vec3( 0.2 ), edgeFactorTri() );

				} else {

					gl_FragColor.rgb = mix( vec3( 1.0 ), vec3( 0.2 ), min( edgeFactorQuad1(), edgeFactorQuad2() ) );

				}

				gl_FragColor.a = 1.0;

			}

		</script>

  <script> 
    var camera, scene, renderer;
    var geometry, material, mesh, ideal;
    var group;

    var targetYRotation = targetXRotation = 0;
    var targetYRotationOnMouseDown = targetXRotationOnMouseDown = 0;

    var mouseX = 0, mouseY = 0;
    var mouseXOnMouseDown = 0;
    var zoomFactor = 1;

    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    var data = [[4, 0, 0], [0, 6, 0], [0, 0, 4]];

    function newMesh(point, geometry, materials) {
      var mesh = new THREE.Mesh( geometry, materials );
      mesh.position.x = point[0] - 1/2;
      mesh.position.y = point[1] - 1/2;
      mesh.position.z = point[2] - 1/2;
      mesh.updateMatrix();
      return mesh;
    }

    // function initCube(s) {
    //   var geometry = new THREE.CubeGeometry( s, s, s );
    //   var faceIndices = [ 'a', 'b', 'c', 'd' ];
    //   var color, point, face, numberOfSides, vertexIndex;
    //   for ( var i = 0; i < geometry.vertices.length; i++ ) 
    //   {
    //     point = geometry.vertices[ i ];
    //     color = new THREE.Color( 0xffffff );
    //     color.setRGB( 0.5 + point.x / s, 0.5 + point.y / s, 0.5 + point.z / s );
    //     geometry.colors[i] = color; // use this array for convenience
    //   }

    //   for (var i = 0; i < geometry.faces.length; i++) {

    //     f = geometry.faces[i];
    //     f.color.setRGB(Math.random(), Math.random(), Math.random());

    //   }

    //   // for ( var i = 0; i < geometry.faces.length; i++ ) 
    //   // {
    //   //   face = geometry.faces[ i ];
    //   //   numberOfSides = ( face instanceof THREE.Face3 ) ? 3 : 4;
    //   //   for( var j = 0; j < numberOfSides; j++ ) 
    //   //   {
    //   //     vertexIndex = face[ faceIndices[ j ] ];
    //   //     face.vertexColors[ j ] = geometry.colors[ vertexIndex ];
    //   //   }
    //   // }

    //   return geometry;
    //   
    // }

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(7,10,15);
      camera.lookAt(new THREE.Vector3(0,2,0));

      renderer = new THREE.WebGLRenderer();
      // renderer = new THREE.CanvasRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);

      document.body.appendChild(renderer.domElement);

      line_material = new THREE.LineBasicMaterial({color: 0x0000ff});
      material = new THREE.MeshBasicMaterial({ vertexColors: THREE.FaceColors, color: 0x00ff00, wireframeLinewidth: 1, shading: THREE.FlatShading, wireframe:false });
      group = new THREE.Object3D();
      geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(0,0,0));
      var s = 1
      var cube = new THREE.CubeGeometry( s, s, s );
      // var cube = initCube(s);

      // var mats = new THREE.MeshFaceMaterial([material]);

      var vertexShader = document.getElementById( 'vertexShader' ).textContent;
      var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;

      // wireframe using gl.TRIANGLES (interpreted as quads)

      var attributesQuads = { center: { type: 'v4', boundTo: 'faceVertices', value: [] } };
      var valuesQuads = attributesQuads.center.value;

      setupAttributes( cube, valuesQuads );

      var materialQuads = new THREE.ShaderMaterial( { uniforms: {}, attributes: attributesQuads, vertexShader: vertexShader, fragmentShader: fragmentShader } );

      // meshQuads = new THREE.Mesh( cube, materialQuads );

      data.forEach(function (d,i) {
        var vec = new THREE.Vector3(d[0],d[1],d[2]);
        geometry.vertices.push(vec);
      });
      geometry.vertices.push(new THREE.Vector3(0,0,0));

      // Is this a good way to add squares?
      // Probably not...
      var maxX = _.max(data, function(d) { return d[0]; })[0];
      maxX = maxX == 0 ? 1 : maxX;
      var maxZ = _.max(data, function(d) { return d[2]; })[2];
      maxZ = maxZ == 0 ? 1 : maxZ;
      console.log(maxX);
      console.log(maxZ);
      var previousMin = 1;
      // var k = 0;
      for(var i = 1; i < maxX + 1; i++) {
        for(var k = 1; k < maxZ + 1; k++) {
          // for(var k = maxZ + 1; k >0; k--) {
          var colPoints = _.filter(data, function(d) { return d[0] == (i) && d[2] == (k); });
          var maxColY = _.max(colPoints, function(d) { return d[1]; })[1];
          // console.log(maxColY);
          if(!maxColY) {
            // console.log(previousMax);
            maxColY = previousMin;
          } 
          else {
            // console.log(maxColY);
            previousMin = _.min(colPoints, function(d) { return d[1]; })[1];
          }

          console.log("max: " + maxColY);
          for(var j = maxColY ; j > 0; j--) {
            // var mesh = newMesh([i,j,k], cube, material);
            var mesh = newMesh([i,j,k], cube, materialQuads);
            group.add(mesh);
          }
        }
      }

      /* var shape  = new THREE.Shape(points); */

      ideal = new THREE.Line(geometry, line_material);
      group.add(ideal);
      /* geometry = new THREE.CubeGeometry(1,1,1); */
      /* cube = new THREE.Mesh(geometry, material); */

      scene.add(group);
      /* camera.position.z = 5; */

      document.addEventListener( 'mousedown', onDocumentMouseDown, false );
      document.addEventListener( 'touchstart', onDocumentTouchStart, false );
      document.addEventListener( 'touchmove', onDocumentTouchMove, false );
      document.addEventListener( 'mousewheel', onMouseWheel, false );

      //

      window.addEventListener( 'resize', onWindowResize, false );
    }

function setupAttributes( geometry, values ) {

				for( var f = 0; f < geometry.faces.length; f ++ ) {

					var face = geometry.faces[ f ];

					if ( face instanceof THREE.Face3 ) {

						values[ f ] = [ new THREE.Vector4( 1, 0, 0, 0 ), new THREE.Vector4( 0, 1, 0, 0 ), new THREE.Vector4( 0, 0, 1, 0 ) ];

					} else {

						values[ f ] = [ new THREE.Vector4( 1, 0, 0, 1 ), new THREE.Vector4( 1, 1, 0, 1 ), new THREE.Vector4( 0, 1, 0, 1 ), new THREE.Vector4( 0, 0, 0, 1 ) ];

					}

				}

			}
    

    function animate() {
      requestAnimationFrame(animate);

      render();
    }

    function render() {

      group.rotation.x = group.rotation.x += ( targetXRotation - group.rotation.x ) * 0.05;
      group.rotation.y = group.rotation.y += ( targetYRotation - group.rotation.y ) * 0.05;

      renderer.render( scene, camera );

    }
    
    init();
    animate();
function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function onDocumentMouseDown( event ) {

				//event.preventDefault();

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mouseout', onDocumentMouseOut, false );

				mouseXOnMouseDown = event.clientX - windowHalfX;
				mouseYOnMouseDown = event.clientY - windowHalfY;
				targetYRotationOnMouseDown = targetYRotation;
				targetXRotationOnMouseDown = targetXRotation;

			}

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

				targetYRotation = targetYRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;
				targetXRotation = targetXRotationOnMouseDown + ( mouseY - mouseYOnMouseDown ) * 0.02;

			}

			function onDocumentMouseUp( event ) {

				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			function onDocumentMouseOut( event ) {

				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
					targetRotationOnMouseDown = targetRotation;

				}
			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;

				}
      }

      function onMouseWheel( event ) {
        event = event ? event : window.event;
        var wheelData = event.detail ? event.detail : event.wheelDelta;
        console.log(event);

				/* if ( event.touches.length == 1 ) { */

				/* 	event.preventDefault(); */

				/* 	mouseX = event.touches[ 0 ].pageX - windowHalfX; */
				/* 	targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05; */

				/* } */
			}

  </script> 
</body> 
</html>
